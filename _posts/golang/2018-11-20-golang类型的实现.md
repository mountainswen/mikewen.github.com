---
layout: post
title: golang数据类型的实现机制
---
内容
-------

- [golang基本数据类型](#基本数据类型)
- [runtime类型](#runtime类型)
- [reflect](#reflect)
- [在标准库中的应用](#应用)

golang基本数据类型
---------
&emsp;&emsp;命令式程序设计(C/C++/JAVA/GO/PYTHON/...)通过改变变量的状态来完成计算过程。变量本质上是对应一个内存地址，内存地址中存储的bit称为变量的值。而如何解析一个地址中所存储的bit，则是由该变量对应的数据类型决定。比如在C语言中，int变量的32个bit被联结起来解析为一个整型数。
&emsp;&emsp;golang也是一门传统的命令式编程语言，因此它具有和其他常用语言相似的语法，同样的，它也实现了类似于其他语言的变量数据类型。基本的数据类型包括8~64位的uint和int，以及float32，float64等，这些和其他语言没有什么本质的区别。golang当然也实现了string类型，不过string类型和C/C++的string还是有很大的不同，它做了一些封装。除此之外，C/C++中以标准库的形式提供的动态数组、哈希表等，golang也是以基本数据类型提供给了用户(slice,map)。
&emsp;&emsp;golang还提供了类似C中void的类型-interface，并基于interface实现了类型反射机制。本文后面还将深入源码了解interface是如何实现void的万能性，以及在此基础上的reflect实现机制。


&emsp;&emsp;**目标**：本文的目标是从源码层面深入理解golang类型实现机制，主要包括各种类型在runtime中的表现形式，以及类型实现的一些周边，包括反射机制等。


&emsp;&emsp;**方法**：反汇编 + 阅读go开源代码

类型的runtime实现
---------
&emsp;&emsp;所谓类型的的runtime实现，指的是类型在程序运行时的底层表现形式。在golang中，所有类型的实现结构体都包含一个统一的头信息：
```go
type _type struct {
	size       uintptr
	ptrdata    uintptr // size of memory prefix holding all pointers
	hash       uint32
	tflag      tflag
	align      uint8
	fieldalign uint8
	kind       uint8
	alg        *typeAlg
	// gcdata stores the GC type data for the garbage collector.
	// If the KindGCProg bit is set in kind, gcdata is a GC program.
	// Otherwise it is a ptrmask bitmap. See mbitmap.go for details.
	gcdata    *byte
	str       nameOff
	ptrToThis typeOff
}
```
结构体包含了类型在运行时的一些元信息，包括类型名称，GC相关等，主要是一些管理信息。在_type的基础上，golang定义了interfacetype,maptype,arraytype,chantype，slicetype,functype,ptrtype,structtype。

&emsp;&emsp;这里，我们关心的是golang在编译期间会分别为这些不同的类型结构体注入哪些信息，以及runtime提供了哪些接口可以获得类型的对应哪些相关的信息。对于第一点，它代表了用户程序所能运用的类型信息的极限，对于第二点，则提供了使用方法。当然这两点是相辅相成的，所以下面我们深入源码看一下runtime中提供的对外获取类型信息的接口，同时基于此了解runtime的类型结构到底包含了哪些信息，以及是如何包含的。