---
layout: post
title: golang数据类型的实现机制
---
内容
-------

- [golang基本数据类型](#基本数据类型)
- [runtime类型](#runtime类型)
- [类型与实例](#类型与实例)
- [reflect](#reflect)
- [在标准库中的应用](#应用)

golang基本数据类型
---------
&emsp;&emsp;命令式程序设计(C/C++/JAVA/GO/PYTHON/...)通过改变变量的状态来完成计算过程。变量本质上是对应一个内存地址，内存地址中存储的bit称为变量的值。而如何解析一个地址中所存储的bit，则是由该变量对应的数据类型决定。比如在C语言中，int变量的32个bit被联结起来解析为一个整型数。

&emsp;&emsp;golang也是一门传统的命令式编程语言，因此它具有和其他常用语言相似的语法，同样的，它也实现了类似于其他语言的变量数据类型。基本的数据类型包括8~64位的uint和int，以及float32，float64等，这些和其他语言没有什么本质的区别。golang当然也实现了string类型，不过string类型和C/C++的string还是有很大的不同，它做了一些封装。除此之外，C/C++中以标准库的形式提供的动态数组、哈希表等，golang也是以基本数据类型提供给了用户(slice,map)。

&emsp;&emsp;golang还提供了类似C中void的类型-interface，并基于interface实现了类型反射机制。本文后面还将深入源码了解interface是如何实现void的万能性，以及在此基础上的reflect实现机制。


&emsp;&emsp;**目标**：本文的目标是从源码层面深入理解golang类型实现机制，主要包括各种类型在runtime中的表现形式，以及类型实现的一些周边，包括反射机制等。


&emsp;&emsp;**方法**：反汇编 + 阅读go开源代码

类型的runtime实现
---------
&emsp;&emsp;所谓类型的的runtime实现，指的是类型在程序运行时的底层表现形式。在golang中，所有类型的实现结构体都包含一个统一的头信息：
```go
type _type struct {
	size       uintptr
	ptrdata    uintptr // size of memory prefix holding all pointers
	hash       uint32
	tflag      tflag
	align      uint8
	fieldalign uint8
	kind       uint8
	alg        *typeAlg
	// gcdata stores the GC type data for the garbage collector.
	// If the KindGCProg bit is set in kind, gcdata is a GC program.
	// Otherwise it is a ptrmask bitmap. See mbitmap.go for details.
	gcdata    *byte
	str       nameOff
	ptrToThis typeOff
}
```
结构体包含了类型在运行时的一些元信息，包括类型名称，GC相关等，主要是一些管理信息。在_type的基础上，golang定义了interfacetype,maptype,arraytype,chantype，slicetype,functype,ptrtype,structtype。具体这些信息就比较显然，就不贴代码了。

&emsp;&emsp;这里，我们关心的是golang在编译期间会分别为这些不同的类型结构体注入哪些信息，以及runtime提供了哪些接口可以获得类型的对应哪些相关的信息。对于第一点，它代表了用户程序所能运用的类型信息的极限，对于第二点，则提供了使用方法。当然这两点是相辅相成的，所以下面我们深入源码看一下runtime中提供的对外获取类型信息的接口，同时基于此了解runtime的类型结构到底包含了哪些信息，以及是如何包含的。一般来说，语言的类型系统主要是为了编译检查，保证程序的稳定性和安全性，用户不需要过多干预语言的类型信息，因此golang对应的接口也比较简单。

&emsp;&emsp;观察type.go，_type实现的函数主要包括以下几个：
```go
func (t *_type) string() string
func (t *_type) uncommon() *uncommontype
func (t *_type) name() string
func (t *_type) pkgpath() string
func (t *_type) nameOff(off nameOff) name
func (t *_type) typeOff(off typeOff) *_type
func (t *_type) textOff(off textOff) unsafe.Pointer
```

其中几个*off函数主要是获取类型在module中的相关信息，比如类型名，包路径等。这里的module指的是定义该类型的模块。这些函数都是根据信息在module镜像文件中的偏移量来获取信息的。

这里比较重要一点的应该是uncommon函数，这个函数提供了根据类型头信息获取类型结构体具体信息的入口。在_type结构体中有一个tflag字段，这个字段告诉外界是否可以通过直接跨越类型头信息的内存区域读取该类型的其他信息。举例来说，对于一个map类型，我们可以通过tflag知道在头部maptype结构体之后是否还存储了该map类型的其他信息，比如该类型实现的method信息等：

```go
func (t *_type) uncommon() *uncommontype { 
	if t.tflag&tflagUncommon == 0 {
		return nil
    }
    ....
    	case kindMap:
		type u struct {
			maptype
			u uncommontype
		}
        return &(*u)(unsafe.Pointer(t)).u
    ....
```

```go
type uncommontype struct {
	pkgpath nameOff
	mcount  uint16 // number of methods
	xcount  uint16 // number of exported methods
	moff    uint32 // offset from this uncommontype to [mcount]method
	_       uint32 // unused
}
```
可以看到主要是method信息(exported or not)。

类型与实例
---------
类型是一个模板，只有真正被程序使用才会创建实例。上一节介绍的就是类型的模板，表现形式位为结构体。我们可以通过程序来验证这一点：
```go
package main

import "reflect"
import "fmt"

func main(){
    var m = make(map[int]int)  \\1
    var n = make(map[int]int)  \\2
    m[1] = 1
    n[1] = 2
    var a interface{}
    var c interface{}
    a = m
    b := reflect.TypeOf(a)

    c = n
    d := reflect.TypeOf(c)
    fmt.Printf("typename:%v,&v\n",b,d)
}
```
上面这段简单的代码片段对应的汇编如下(部分)：
```
....
  test.go:6		0x1092987		488dac2490000000	LEAQ 0x90(SP), BP
  test.go:7		0x109298f		e84c8df7ff		CALL runtime.makemap_small(SB)
  test.go:7		0x1092994		488b0424		MOVQ 0(SP), AX
  test.go:7		0x1092998		4889442448		MOVQ AX, 0x48(SP)
  test.go:8		0x109299d		e83e8df7ff		CALL runtime.makemap_small(SB)
  test.go:8		0x10929a2		488b0424		MOVQ 0(SP), AX
  test.go:8		0x10929a6		4889442440		MOVQ AX, 0x40(SP)
  test.go:9		0x10929ab		488d0d6e6b0100		LEAQ runtime.rodata+92288(SB), CX
  test.go:9		0x10929b2		48890c24		MOVQ CX, 0(SP)
  test.go:9		0x10929b6		488b542448		MOVQ 0x48(SP), DX
  test.go:9		0x10929bb		4889542408		MOVQ DX, 0x8(SP)
  test.go:9		0x10929c0		48c744241001000000	MOVQ $0x1, 0x10(SP)
  test.go:9		0x10929c9		e802bef7ff		CALL runtime.mapassign_fast64(SB)
  test.go:9		0x10929ce		488b442418		MOVQ 0x18(SP), AX
  test.go:9		0x10929d3		48c70001000000		MOVQ $0x1, 0(AX)
  test.go:10		0x10929da		488d053f6b0100		LEAQ runtime.rodata+92288(SB), AX
  test.go:10		0x10929e1		48890424		MOVQ AX, 0(SP)
.....
```
可以看到对于两个变量n、m，虽然是两个不同的变量，但是由于类型相同，都是map[int]int,因此这两个实例使用的runtime类型结构体是一样的。从以上代码可以看到，类型模板结构体存储在runtime.rodata区域，是程序的只读数据区，程序的所有类型模板结构体都将存储在这个位置。